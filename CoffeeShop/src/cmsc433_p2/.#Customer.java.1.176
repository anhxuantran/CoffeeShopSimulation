package cmsc433_p2;

/*Name: Anh Tran
 * UID: 112126346
 * */

import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.ReentrantLock;
import java.util.HashMap;

/**
 * Customers are simulation actors that have two fields: a name, and a list of
 * Food items that constitute the Customer's order. When running, an customer
 * attempts to enter the restaurant (only successful if the restaurant has a
 * free table), place its order, and then leave the restaurant when the order is
 * complete.
 */
public class Customer implements Runnable {
	// JUST ONE SET OF IDEAS ON HOW TO SET THINGS UP...
	private final String name;
	private final LinkedList<Food> order;
	private final int orderNum;

	private static int runningCounter = 0;
	private static int numTables;

	// static CountDownLatch starterDelay, joinerLatch;
	private static Semaphore tableSpace = null;
	/**
	 * You can feel free modify this constructor. It must take at least the name
	 * and order but may take other parameters if you would find adding them
	 * useful.
	 */

	ReentrantLock sharedLock;

	HashMap<Customer, LinkedList<Food>> custMap = null;
	LinkedList<FoodOrder> orders = null;

	public Customer(String name, LinkedList<Food> order, int numTablesIn,
			LinkedList<FoodOrder> orderList, ReentrantLock lockIn,
			HashMap<Customer, LinkedList<Food>> map) {

		this.name = name;
		this.order = order;
		this.orderNum = ++runningCounter;

		if (tableSpace == null) {
			numTables = numTablesIn;
			tableSpace = new Semaphore(numTables);
		}

		custMap = map;
		orders = orderList;
		sharedLock = lockIn;

	}

	public String toString() {
		return name;
	}

	public int getOrderNum() {
		return this.orderNum;
	}

	/**
	 * This method defines what an Customer does: The customer attempts to enter
	 * the restaurant (only successful when the restaurant has a free table),
	 * place its order, and then leave the restaurant when the order is
	 * complete.
	 */
	// private ReentrantLock lock = new ReentrantLock();

	public void run() {

		Simulation.logEvent(SimulationEvent.customerStarting(this));
		try {
			/*
			 * Customer attempts to enter the coffee shop here The Semaphore
			 * blocks them when it reaches 0.
			 */
			tableSpace.acquire();

			synchronized (custMap) {
				custMap.put(this, this.order);
			}
			/* The simulation logs the event once they have entered in */
			Simulation
					.logEvent(SimulationEvent.customerEnteredCoffeeShop(this));

			synchronized (orders) {
				orders.add(new FoodOrder(this.orderNum, this.order, this));
				orders.notifyAll();
			}
			synchronized (sharedLock) {
				sharedLock.wait();
				Simulation.logEvent(SimulationEvent.customerPlacedOrder(this,
						this.order, this.orderNum));
			}
			synchronized (custMap.get(this)) {
				custMap.get(this).wait();
				Simulation.logEvent(SimulationEvent.customerReceivedOrder(this,
						this.order, this.orderNum));
				
			}
			Simulation
			.logEvent(SimulationEvent.customerLeavingCoffeeShop(this));
			tableSpace.release();

			
		} catch (InterruptedException e) {
			
		}
	}
}