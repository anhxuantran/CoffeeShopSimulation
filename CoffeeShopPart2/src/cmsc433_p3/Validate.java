package cmsc433_p3;

import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import cmsc433_p3.SimulationEvent;
import cmsc433_p3.SimulationEvent.EventType;

/**
 * Validates a simulation
 */
public class Validate {
	private static class InvalidSimulationException extends Exception {
		public InvalidSimulationException() {
		}
	};

	// Helper method for validating the simulation
	private static void check(boolean check, String message)
			throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : " + message);
			throw new Validate.InvalidSimulationException();
		}
	}

	/**
	 * Validates the given list of events is a valid simulation. Returns true if
	 * the simulation is valid, false otherwise.
	 * 
	 * @param events
	 *            - a list of events generated by the simulation in the order
	 *            they were generated.
	 * 
	 * @returns res - whether the simulation was valid or not
	 */

	/*
	 * In P3 you will write validation code for things such as: Should not have
	 * more eaters than specified Should not have more cooks than specified The
	 * restaurant capacity should not be exceeded The capacity of each machine
	 * should not be exceeded Eater should not receive order until cook
	 * completes it Eater should not leave restaurant until order is received
	 * Eater should not place more than one order Cook should not work on order
	 * before it is placed
	 */

	public static boolean validateSimulation(List<SimulationEvent> events) {
		try {

			HashMap<Machine, Integer> counterCapacity = new HashMap<Machine, Integer>();
			HashMap<Integer, Boolean> ordersPlaced = new HashMap<Integer, Boolean>();
			HashMap<Cook, Integer> cookCurrentOrder = new HashMap<Cook, Integer>();
			HashMap<Cook, Integer> cookAmount = new HashMap<Cook, Integer>();
			HashMap<Cook, List<Food>> cookOrder = new HashMap<Cook, List<Food>>();
			HashMap<SimulationEvent.EventType, HashMap<String, Integer>> cooking = new HashMap<SimulationEvent.EventType, HashMap<String, Integer>>();

			List<Customer> custGoingToShop = new ArrayList<Customer>();
			List<Customer> custEnteredShop = new ArrayList<Customer>();
			List<Cook> cooksWhoLeft = new ArrayList<Cook>();
			List<Cook> cooksAvailable = new ArrayList<Cook>();
			List<String> custNames = new ArrayList<String>();

			boolean machinesLeft = false;

			int customerCount = 0;
			int custParamCheck1 = 0;
			int custParamCheck2 = 0;
			int cookParamCheck = 0;
			int numTablesCheck = 0;
			int[] params;

			if (events.get(0).event != SimulationEvent.EventType.SimulationStarting) {
				check(false, "Simulation didn't start with initiation event");

			}

			params = new int[events.get(0).simParams.length];

			for (int i = 0; i < events.get(0).simParams.length; i++) {
				params[i] = events.get(0).simParams[i];
			}

			if (events.get(events.size() - 1).event != SimulationEvent.EventType.SimulationEnded) {
				check(false, "Simulation didn't end with termination event");
			}

			/**
			 * This iterates through the events to check the correct sequence
			 * order.
			 **/

			cooking.put(EventType.CookStartedFood, new HashMap<String, Integer>());
			cooking.put(EventType.MachineStartingFood,
					new HashMap<String, Integer>());

			for (SimulationEvent curr : events) {
				/******* This is the section that does the machines validity *******/
				if (curr.event == EventType.MachineStarting) {
					if (counterCapacity.containsKey(curr.machine))
						check(false, "Machine exists already");
					counterCapacity.put(curr.machine, 0);
					cooking.get(EventType.CookStartedFood).put(curr.food.toString(), 0);
					cooking.get(EventType.MachineStartingFood).put(curr.food.toString(), 0);
				}

				if (curr.event == EventType.MachineEnding) {
					if (!counterCapacity.containsKey(curr.machine)) {
						check(false,
								"This machine does not exist or never started");
					}
					machinesLeft = true;
				}

				if (curr.event == EventType.MachineStartingFood) {
					if (!cooking.get(EventType.MachineStartingFood)
							.containsKey(curr.food.toString())) {
						cooking.get(EventType.MachineStartingFood).put(
								curr.food.toString(), 0);
					}
					if (cooking.get(EventType.CookStartedFood).get(curr.food.toString()) == 0) {
						check(false, "Machine is cooking before cook is");
					}
					int k = cooking.get(curr.event).get(curr.food.toString());
					cooking.get(curr.event).put(curr.food.toString(), k + 1);
					if (!counterCapacity.containsKey(curr.machine)) {
						check(false, "Machine does not exist");
					}
					if (machinesLeft) {
						check(false, "Machines left before starting food");
					}

					if (!curr.food.name
							.equals(curr.machine.machineFoodType.name)) {
						check(false, "Machine is not making the correct food");
					}

					k = counterCapacity.get(curr.machine);

					if (k + 1 > curr.machine.capacity) {
						check(false, "Machine has exceeded capacity");
					}
					counterCapacity.put(curr.machine, k + 1);
				}

				if (curr.event == EventType.MachineDoneFood) {
					int k = cooking.get(EventType.MachineStartingFood).get(
							curr.food.toString());
					if (k == 0) {
						check(false,
								"Machine is done with food before starting " + curr.orderNumber);
					}
					cooking.get(EventType.MachineStartingFood).put(curr.food.toString(),
							k - 1);
					if (machinesLeft) {
						check(false, "Machine left before finishing food");
					}
					k = counterCapacity.get(curr.machine);
					if (k == 0) {
						check(false, "Machine has never started Food");
					}
					counterCapacity.put(curr.machine, k - 1);
				}
				/*****************************************************************/
				/************* These are the customer validity section ***********/

				if (curr.event == EventType.CustomerStarting) {
					if (custNames.contains(curr.customer.toString())) {
						check(false, "customer cannot have the same name");
					}
					custNames.add(curr.customer.toString());
					if (custGoingToShop.contains(curr.customer)) {
						check(false, "Customer has already entered");
					}
					custGoingToShop.add(curr.customer);
					custParamCheck1++;
				}

				if (curr.event == EventType.CustomerEnteredCoffeeShop) {
					if (custEnteredShop.contains(curr.customer)) {
						check(false, "Customer has already entered");
					}
					custEnteredShop.add(curr.customer);
					if (!custGoingToShop.contains(curr.customer)) {
						check(false, "Customer has never gone to shop");
					}
					if (numTablesCheck + 1 > params[2]) {
						check(false, "Exceeded number of tables");
					}
					numTablesCheck++;
					custParamCheck2++;
					customerCount++;
				}

				if (curr.event == EventType.CustomerPlacedOrder) {
					if (counterCapacity.size() == 0) {
						check(false, "Machines have not started");
					}
					if (!custEnteredShop.contains(curr.customer)) {
						check(false, "Customer " + curr.customer.toString()
								+ " has not entered shop");
					}

					if (!custGoingToShop.contains(curr.customer)) {
						check(false, "Customer has never gone to shop");
					}

					if (ordersPlaced.containsKey(curr.orderNumber)) {
						check(false, "Order number has been placed already");
					}

					ordersPlaced.put(curr.orderNumber, false);
				}

				if (curr.event == EventType.CustomerReceivedOrder) {
					if (machinesLeft) {
						check(false,
								"Machines have shut down before customer received order");
					}

					if (!ordersPlaced.containsKey(curr.orderNumber)) {
						check(false, "Order " + curr.orderNumber
								+ " was never Placed");
					}
					if (ordersPlaced.get(curr.orderNumber) == false) {
						check(false, "Customer " + curr.customer.toString()
								+ " has received order before Cook finished ");
					}
				}

				if (curr.event == EventType.CustomerLeavingCoffeeShop) {
					if (numTablesCheck - 1 < 0) {
						check(false, "Too many Customers are leaving");

					}
					numTablesCheck--;
					custGoingToShop.remove(curr.customer);
					customerCount--;
				}

				/****************************************************************/
				/****************** This is the cook validity section ***********/

				if (curr.event == EventType.CookStarting) {
					if (machinesLeft) {
						check(false, "No machines to use");
					}
					if (cooksWhoLeft.contains(curr.cook)) {
						check(false, "This cook has left and tried to reenter");
					}
					if (cooksAvailable.contains(curr.cook)) {
						check(false, "This cook already exists");

					}
					if (cookAmount.containsKey(curr.cook)) {
						check(false, "This cook has already started");
					}
					if (cookOrder.containsKey(curr.cook)) {
						check(false, "This cook already started");
					}
					cookAmount.put(curr.cook, 0);
					cookOrder.put(curr.cook, null);
					cookParamCheck++;
					cooksAvailable.add(curr.cook);
				}

				if (curr.event == EventType.CookReceivedOrder) {
					if (machinesLeft) {
						check(false, "No machines to use");
					}
					if (cooksWhoLeft.contains(curr.cook)) {
						check(false,
								"This cook has left and cannot received an order");
					}
					if (!cooksAvailable.contains(curr.cook)
							|| !cookAmount.containsKey(curr.cook)) {
						check(false, "Cook " + curr.cook.toString()
								+ " has not shown up for work yet");
					}
					if (!ordersPlaced.containsKey(curr.orderNumber)) {
						check(false, "No such order " + curr.orderNumber
								+ " has been placed");

					} else if (ordersPlaced.get(curr.orderNumber) == true) {
						check(false, "Order has been made already");
					}
					if (cookCurrentOrder.containsKey(curr.cook)) {
						check(false, "Cook has taken an order already");
					}
					if (cookOrder.get(curr.cook) != null) {
						check(false, "Cook has taken an order");
					}

					cookOrder.put(curr.cook, curr.orderFood);
					cookCurrentOrder.put(curr.cook, curr.orderNumber);
				}

				if (curr.event == EventType.CookStartedFood) {

					int k = cooking.get(EventType.CookStartedFood).get(
							curr.food.toString());
					cooking.get(EventType.CookStartedFood)
							.put(curr.food.toString(), k + 1);
					if (machinesLeft) {
						check(false, "Machine has shut down");
					}
					if (!cooksAvailable.contains(curr.cook)
							|| !cookAmount.containsKey(curr.cook)) {
						check(false, "Cook does not exist");
					}

					if (!ordersPlaced.containsKey(curr.orderNumber))
						check(false, "This order number does not exist");

					k = cookAmount.get(curr.cook);
					cookAmount.put(curr.cook, k + 1);
				}

				if (curr.event == EventType.CookFinishedFood) {
					
					int k = cooking.get(EventType.CookStartedFood).get(curr.food.toString());
					
					if (k == 0) {
						check(false, "Cook finished Food too early " + curr.orderNumber);
					}
					cooking.get(EventType.CookStartedFood)
							.put(curr.food.toString(), k - 1);

					if (!cooksAvailable.contains(curr.cook)
							|| !cookAmount.containsKey(curr.cook)) {
						check(false, "Cook has not shown up");
					}

					if (!ordersPlaced.containsKey(curr.orderNumber)) {
						check(false, "This order number does not exist");
					}
					k = cookAmount.get(curr.cook);

					if (k < 0) {
						check(false, "Cook has finished food before starting");
					}
					cookAmount.put(curr.cook, k - 1);

				}

				if (curr.event == EventType.CookCompletedOrder) {
					if (!cookCurrentOrder.containsKey(curr.cook)
							|| !cookOrder.containsKey(curr.cook)) {
						check(false, "Cook has not taken an order");
					}
					if (cookCurrentOrder.get(curr.cook) != curr.orderNumber) {
						check(false,
								"Cook's current order is not the same as completed");
					}
					if (!ordersPlaced.containsKey(curr.orderNumber)) {
						check(false, "No such order " + curr.orderNumber
								+ " has been placed");
					}
					cookOrder.put(curr.cook, null);
					ordersPlaced.put(curr.orderNumber, true);
					cookCurrentOrder.remove(curr.cook);
				}

				if (curr.event == EventType.CookEnding) {
					if (cooksWhoLeft.contains(curr.cook)) {
						check(false, "Cook has Left Already");
					}
					cooksWhoLeft.add(curr.cook);
					cooksAvailable.remove(curr.cook);
				}
				/*****************************************************************/

			}

			/**
			 * These check the rest of the validity at the end of the simulation
			 */

			if (custParamCheck1 != params[0]) {
				check(false,
						"Number of customers who started are not the same in simulation");
			}
			if (custParamCheck2 != params[0]) {
				check(false,
						"Number of customers who entered are not the same in simulation");
			}
			if (cookParamCheck != params[1]) {
				check(false, "Number of cooks is not the same in simulation");
			}

			for (Machine machine : counterCapacity.keySet()) {
				if (counterCapacity.get(machine) != 0) {
					check(false, "There are still food in the machine: "
							+ machine.toString());
				}
			}

			if (custGoingToShop.size() != 0) {
				check(false,
						"There are still customers who have not placed orders");
			}

			String temp = "Cooks: ";

			for (int i = 0; i < cooksAvailable.size(); i++) {
				temp += cooksAvailable.get(i).toString() + " ";
			}

			if (cooksAvailable.size() != 0) {
				check(false, temp + "did not go home");
			}

			switch (customerCount) {
			case 0:
				break;
			default:
				check(false, "Not all customers have left");
			}

			
			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}
	}
}
